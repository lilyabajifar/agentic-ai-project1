
import os
import re
from datetime import datetime
import dateparser
from dotenv import load_dotenv

load_dotenv()

# ---------- Offline fallback: simple heuristics ----------
ACTION_WORDS = [
    "finish", "complete", "study", "email", "reply", "send", "schedule",
    "call", "clean", "submit", "prepare", "review", "write", "read", "fix",
    "organize", "meet", "attend", "buy", "pay"
]

def _estimate_minutes(task: str) -> int:
    t = task.lower()
    if "study" in t: return 120
    if "exam" in t: return 90
    if "laundry" in t or "wash" in t: return 60
    if "clean" in t or "tidy" in t: return 45
    if "email" in t or "reply" in t or "send" in t: return 15
    if "dentist" in t or "appointment" in t: return 60
    return 30

def _priority(task: str, due_iso: str | None) -> str:
    t = task.lower()
    if any(k in t for k in ["today", "eod", "asap", "urgent", "exam", "deadline", "tomorrow"]):
        return "high"
    if due_iso:
        try:
            due_dt = datetime.fromisoformat(due_iso)
            if (due_dt - datetime.now()).days <= 2:
                return "high"
        except Exception:
            pass
    if any(k in t for k in ["before weekend", "this week"]):
        return "medium"
    return "medium" if any(w in t for w in ["finish", "complete", "submit", "schedule"]) else "low"

def _split_sentences(text: str):
    parts = re.split(r"[.\n!?]+", text)
    return [p.strip() for p in parts if p.strip()]

def extract_tasks_offline(text: str):
    sentences = _split_sentences(text)
    tasks = []
    for s in sentences:
        lower = s.lower()
        if any(w in lower for w in ACTION_WORDS):
            due_dt = dateparser.parse(s, settings={"PREFER_DATES_FROM": "future"})
            due_iso = due_dt.isoformat() if due_dt else None
            prio = _priority(s, due_iso)
            est = _estimate_minutes(s)
            tasks.append({
                "title": s[:140],
                "due": due_iso,
                "priority": prio,
                "estimate_min": est,
            })
    if not tasks and sentences:
        for s in sentences:
            tasks.append({"title": s[:140], "due": None, "priority": "low", "estimate_min": 30})
    return tasks

def render_markdown_plan(tasks: list[dict], title: str = "Daily Productivity Plan") -> str:
    order = {"high": 0, "medium": 1, "low": 2}
    tasks_sorted = sorted(tasks, key=lambda t: (order.get(t["priority"], 2), t.get("due") or ""))

    lines = [f"# {title}", ""]
    lines.append("## Extracted Tasks")
    if not tasks_sorted:
        lines.append("_No tasks found. Add items to `tasks.txt` and re-run._")
    for t in tasks_sorted:
        due_str = t["due"][:16].replace("T", " ") if t["due"] else "—"
        lines.append(f"- **{t['title']}** — Priority: **{t['priority']}**, Due: _{due_str}_, Est: {t['estimate_min']} min")
    lines.append("")
    lines.append("---")
    lines.append("")
    lines.append("## Suggested Order for Today")
    total = 0
    for i, t in enumerate(tasks_sorted, start=1):
        total += t["estimate_min"]
        lines.append(f"{i}. {t['title']}  _(~{t['estimate_min']} min, {t['priority']})_")
    lines.append("")
    lines.append(f"**Total estimated time:** ~{total} min")
    lines.append("")
    lines.append("## Notes")
    lines.append("- This plan was generated by an offline fallback (no API credits needed).")
    lines.append("- When API credits are available, the agent will switch to an LLM for richer planning.")
    return "\n".join(lines)

# ---------- LLM path (optional; falls back if quota or missing package) ----------
def generate_plan_via_llm(text: str) -> str:
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        raise RuntimeError("OPENAI_API_KEY not set")

    try:
        from openai import OpenAI
        client = OpenAI(api_key=api_key)
        prompt = f"""
        You are a personal productivity AI agent.
        Analyze the user's tasks and create a clear, organized plan.

        From the text, extract:
        - Task list
        - Deadlines / dates (if any)
        - Priority (high / medium / low)
        - Estimated time needed
        - Suggested order for today
        - A final structured schedule

        Return the answer in clean Markdown.
        TEXT:
        {text}
        """
        resp = client.chat.completions.create(
            model="gpt-4.1-mini",
            messages=[{"role": "user", "content": prompt}],
        )
        return resp.choices[0].message.content
    except Exception as e:
        raise e

def main():
    with open("tasks.txt", "r") as f:
        text = f.read().strip()

    plan_md = None
    try:
        plan_md = generate_plan_via_llm(text)
        print("✅ Generated plan via OpenAI model.")
    except Exception as e:
        print(f"⚠️ LLM unavailable ({type(e).__name__}: {e}). Falling back to offline planner...")
        tasks = extract_tasks_offline(text)
        plan_md = render_markdown_plan(tasks)

    with open("daily_plan.md", "w") as f:
        f.write(plan_md)
    print("✨ Your daily plan is ready! See daily_plan.md")

if __name__ == "__main__":
    main()






